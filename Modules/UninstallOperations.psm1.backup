<#
.SYNOPSIS
    Uninstall operations module for Autodesk Uninstaller
.DESCRIPTION
    Handles uninstallation, service management, and cleanup operations
#>

<#
.SYNOPSIS
    Stops Autodesk services and processes
.DESCRIPTION
    Stops common Autodesk services and kills related processes
#>
function Stop-AutodeskServices {
    Write-ActionLog "Stopping Autodesk services and processes..."
    
    $config = Get-Config
    $services = $config.AutodeskServices
    $processes = $config.AutodeskProcesses
    
    # Stop common Autodesk services
    foreach ($service in $services) {
        try {
            Stop-Service $service -Force -ErrorAction SilentlyContinue
            Set-Service $service -StartupType Disabled -ErrorAction SilentlyContinue
            Write-ActionLog "Stopped service: $service"
        } catch { 
            Write-ActionLog "Could not stop service: $service"
        }
    }
    
    # Kill popup processes
    foreach ($proc in $processes) {
        try {
            Stop-Process -Name $proc -Force -ErrorAction SilentlyContinue
            Write-ActionLog "Killed process: $proc"
        } catch {
            Write-ActionLog "Could not kill process: $proc"
        }
    }
}

<#
.SYNOPSIS
    Uninstalls a specific Autodesk product
.DESCRIPTION
    Uninstalls a product using its uninstall string
.PARAMETER Product
    The product object containing uninstall information
.OUTPUTS
    Boolean indicating success or failure
#>
function Uninstall-Product {
    param([PSCustomObject]$Product)
    
    Write-ActionLog "Uninstalling: $($Product.DisplayName)"
    $exitCode = $null
    
    try {
        if ($Product.UninstallString -match '^(.*?Installer\.exe)(.*)$') {
            # ODIS installer
            $exePath = $matches[1].Trim('"')
            $argList = $matches[2].Trim()
            if ($argList -notmatch '\b-i\s+uninstall\b') { 
                $argList = "-i uninstall $argList" 
            }
            if ($argList -notmatch '\b--silent\b') { 
                $argList += ' --silent' 
            }
            
            Write-ActionLog "Command: $exePath $argList"
            $proc = Start-Process $exePath $argList -WindowStyle Hidden -Wait -PassThru
            $exitCode = $proc.ExitCode
            
        } elseif ($Product.UninstallString -match '/[IX]\s*\{([^\}]+)\}') {
            # MSI installer
            $guid = $Matches[1]
            $logPath = Get-LogPath
            $argList = "/X `{$guid`} /qn /l*v `"$logPath\MSI_$($Product.DisplayName -replace '[^\w]','_').log`""
            
            Write-ActionLog "Command: msiexec.exe $argList"
            $proc = Start-Process msiexec.exe $argList -WindowStyle Hidden -Wait -PassThru
            $exitCode = $proc.ExitCode
            
        } else {
            Write-ActionLog "Unknown uninstall method for $($Product.DisplayName)"
            return $false
        }
        
        if ($exitCode -in 0, 1605, 3010) {
            Write-ActionLog "Successfully uninstalled: $($Product.DisplayName) (Exit code: $exitCode)"
            return $true
        } else {
            Write-ActionLog "Failed to uninstall: $($Product.DisplayName) (Exit code: $exitCode)"
            return $false
        }
        
    } catch {
        Write-ActionLog "Error uninstalling $($Product.DisplayName): $_"
        return $false
    }
}

<#
.SYNOPSIS
    Backs up add-ins for a specific product type
.DESCRIPTION
    Creates a backup of add-ins and plugins for reinstallation scenario
.PARAMETER ProductType
    The type of product to backup add-ins for
.OUTPUTS
    Array of backed up items
#>
function Backup-AddIns {
    param([string]$ProductType)
    
    Write-ActionLog "Backing up add-ins for $ProductType..."
    $timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
    $config = Get-Config
    $backupPath = "$($config.AddInsBackupRootPath)\$timestamp"
    Set-AddInsBackupPath -value $backupPath
    
    [void](New-Item -ItemType Directory -Path $backupPath -Force)
    
    $backedUpItems = @()
    $addInPaths = $config.AddInPaths
    
    # Get all user profiles
    $profiles = Get-UserProfiles
    
    foreach ($userProfile in $profiles) {
        $profilePath = $userProfile.ProfileImagePath
        $userName = Split-Path $profilePath -Leaf
        
        foreach ($location in @('AppData\Local', 'AppData\Roaming')) {
            $basePath = Join-Path $profilePath $location
            
            if ($addInPaths.ContainsKey($ProductType)) {
                foreach ($addInDef in $addInPaths[$ProductType]) {
                    $fullPath = Join-Path $basePath $addInDef.Path
                    
                    if (Test-Path $fullPath) {
                        $items = Get-ChildItem -Path $fullPath -Filter $addInDef.Pattern -Recurse -ErrorAction SilentlyContinue
                        
                        foreach ($item in $items) {
                            $relativePath = $item.FullName.Substring($profilePath.Length + 1)
                            $destPath = Join-Path $backupPath "$userName\$relativePath"
                            $destDir = Split-Path $destPath -Parent
                            
                            [void](New-Item -ItemType Directory -Path $destDir -Force -ErrorAction SilentlyContinue)
                            Copy-Item -Path $item.FullName -Destination $destPath -Force -ErrorAction SilentlyContinue
                            
                            $backedUpItems += @{
                                Source = $item.FullName
                                Destination = $destPath
                                User = $userName
                            }
                            
                            Write-ActionLog "Backed up: $($item.FullName) -> $destPath"
                        }
                    }
                }
            }
        }
    }
    
    Write-ActionLog "Backed up $($backedUpItems.Count) add-in items to: $backupPath"
    return $backedUpItems
}

<#
.SYNOPSIS
    Clears product data from the system
.DESCRIPTION
    Removes product files and user data with optional add-in preservation
.PARAMETER ProductType
    The type of product to clear data for
.PARAMETER PreserveAddIns
    Whether to preserve add-ins and plugins
#>
function Clear-ProductData {
    param(
        [string]$ProductType,
        [bool]$PreserveAddIns
    )
    
    Write-ActionLog "Clearing $ProductType data (PreserveAddIns: $PreserveAddIns)..."
    
    $config = Get-Config
    $productPaths = $config.ProductPaths
    
    # Clear product-specific paths
    if ($productPaths.ContainsKey($ProductType)) {
        foreach ($pathPattern in $productPaths[$ProductType]) {
            foreach ($path in Get-Item $pathPattern -ErrorAction SilentlyContinue) {
                Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed: $path"
            }
        }
    }
    
    # Clear user data
    $profiles = Get-UserProfiles
    
    foreach ($userProfile in $profiles) {
        $profilePath = $userProfile.ProfileImagePath
        
        if (-not $PreserveAddIns) {
            # Full cleanup - remove everything
            Clear-AllAutodeskUserData -ProfilePath $profilePath
        } else {
            # Selective cleanup - preserve add-ins
            Clear-SelectiveAutodeskUserData -ProfilePath $profilePath
        }
        
        # Clean up Desktop Autodesk files
        Clear-DesktopAutodeskFiles -ProfilePath $profilePath
    }
    
    # Perform deep system cleanup to prevent reinstallation issues
    # Pass the preserve mode - if preserving add-ins, also preserve critical components
    Clear-AutodeskSystemRemnants -PreserveComponents $PreserveAddIns
}

<#
.SYNOPSIS
    Gets all user profiles from the registry
.DESCRIPTION
    Retrieves user profile information from the registry
.OUTPUTS
    Array of user profile objects
#>
function Get-UserProfiles {
    return Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | 
           Where-Object { $_.PSObject.Properties.Name -contains 'ProfileImagePath' -and $_.ProfileImagePath }
}

<#
.SYNOPSIS
    Clears all Autodesk user data
.DESCRIPTION
    Removes all Autodesk data from user profile directories
.PARAMETER ProfilePath
    The path to the user profile
#>
function Clear-AllAutodeskUserData {
    param([string]$ProfilePath)
    
    foreach ($appData in @('AppData\Local\Autodesk', 'AppData\Roaming\Autodesk')) {
        $fullPath = Join-Path $ProfilePath $appData
        if (Test-Path $fullPath) {
            Get-ChildItem $fullPath -Recurse -File | ForEach-Object {
                Write-ActionLog "Deleting: $($_.FullName)"
            }
            Remove-Item $fullPath -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}

<#
.SYNOPSIS
    Selectively clears Autodesk user data
.DESCRIPTION
    Removes Autodesk data while preserving add-ins and plugins
.PARAMETER ProfilePath
    The path to the user profile
#>
function Clear-SelectiveAutodeskUserData {
    param([string]$ProfilePath)
    
    $config = Get-Config
    $preservePaths = $config.PreservePaths
    
    foreach ($appData in @('AppData\Local\Autodesk', 'AppData\Roaming\Autodesk')) {
        $basePath = Join-Path $ProfilePath $appData
        if (Test-Path $basePath) {
            Get-ChildItem $basePath -Recurse -File | ForEach-Object {
                $shouldPreserve = $false
                foreach ($pattern in $preservePaths) {
                    if ($_.FullName -like $pattern) {
                        $shouldPreserve = $true
                        break
                    }
                }
                
                if (-not $shouldPreserve) {
                    Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Deleted: $($_.FullName)"
                } else {
                    Write-ActionLog "Preserved: $($_.FullName)"
                }
            }
        }
    }
}

<#
.SYNOPSIS
    Clears Autodesk system remnants that can cause reinstallation issues
.DESCRIPTION
    Performs deep cleanup of registry entries, system files, and services.
    Can preserve critical components for reinstall scenarios.
.PARAMETER PreserveComponents
    If true, preserves critical shared components and licensing for reinstall scenarios
#>
function Clear-AutodeskSystemRemnants {
    param(
        [bool]$PreserveComponents = $false
    )
    
    if ($PreserveComponents) {
        Write-ActionLog "Performing selective system cleanup (REINSTALL MODE - preserving critical components)..."
    } else {
        Write-ActionLog "Performing comprehensive system cleanup (FULL UNINSTALL MODE)..."
    }
    
    $config = Get-Config
    
    # Clean registry entries (safe for both modes)
    Clear-AutodeskRegistryEntries
    
    # Clean licensing components with preservation mode
    Clear-AutodeskLicensingComponents -PreserveLicensing $PreserveComponents
    
    # Clean shared components with preservation mode
    Clear-AutodeskSharedComponents -PreserveComponents $PreserveComponents
    
    if (-not $PreserveComponents) {
        # Only do these in full uninstall mode
        # Clean system files
        Clear-AutodeskSystemFiles
        
        # Clean Windows Installer cache
        Clear-AutodeskInstallerCache
    } else {
        Write-ActionLog "Skipping system files and installer cache cleanup to preserve system integrity"
    }
}

<#
.SYNOPSIS
    Clears Autodesk licensing components that cause "License Manager not functioning" errors
.DESCRIPTION
    Removes ADLM, FLEXnet, and other licensing-related components.
    In reinstall mode, preserves core licensing infrastructure.
.PARAMETER PreserveLicensing
    If true, preserves core licensing components for reinstall scenarios
#>
function Clear-AutodeskLicensingComponents {
    param(
        [bool]$PreserveLicensing = $false
    )
    
    if ($PreserveLicensing) {
        Write-ActionLog "Performing selective licensing cleanup (REINSTALL MODE - preserving core licensing)..."
        
        # In reinstall mode, only clear cache and temporary licensing data
        Write-ActionLog "Preserving AdskIdentityManager and core licensing infrastructure..."
        
        # Only stop problematic licensing processes, keep core ones running
        $problematicProcesses = @('adlmint', 'lmgrd')  # Don't stop adskflex or core services
        foreach ($proc in $problematicProcesses) {
            try {
                Stop-Process -Name $proc -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Stopped problematic licensing process: $proc"
            } catch {
                Write-ActionLog "Process not running: $proc"
            }
        }
        
        # Clear only cache/temp licensing files, not core infrastructure
        $safeLicensingPaths = @(
            'C:\ProgramData\FLEXnet\*cache*',
            'C:\ProgramData\FLEXnet\*temp*', 
            'C:\ProgramData\FLEXnet\*log*',
            'C:\ProgramData\Autodesk\ADLM\*cache*',
            'C:\ProgramData\Autodesk\ADLM\*temp*',
            'C:\ProgramData\Autodesk\ADLM\*log*',
            'C:\Windows\ServiceProfiles\NetworkService\AppData\Roaming\Autodesk\ADLM\*cache*'
        )
        
        foreach ($path in $safeLicensingPaths) {
            try {
                $items = Get-Item $path -ErrorAction SilentlyContinue
                foreach ($item in $items) {
                    Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Cleaned licensing cache: $($item.FullName)"
                }
            } catch {
                Write-ActionLog "Could not clean licensing cache: $path"
            }
        }
        
        # Clear only user-specific licensing data, not system-wide
        Clear-UserLicensingData
        
        Write-ActionLog "Core licensing infrastructure preserved for reinstall"
        
    } else {
        Write-ActionLog "Performing comprehensive licensing cleanup (FULL UNINSTALL MODE)..."
        
        # Full uninstall mode: Remove all licensing components
        # Stop all licensing-related processes
        $licensingProcesses = @('adlmint', 'adlmact', 'lmgrd', 'adskflex', 'FNPLicensingService')
        foreach ($proc in $licensingProcesses) {
            try {
                Stop-Process -Name $proc -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Stopped licensing process: $proc"
            } catch {
                Write-ActionLog "Process not running or already stopped: $proc"
            }
        }
        
        # Remove licensing files and folders
        $config = Get-Config
        $licensingPaths = $config.LicensingCleanupPaths
        
        foreach ($path in $licensingPaths) {
            try {
                if (Test-Path $path) {
                    # Special handling for system files
                    if ($path -match 'System32|SysWOW64') {
                        Get-ChildItem $path -ErrorAction SilentlyContinue | Where-Object { 
                            $_.Name -like '*adlm*' -or $_.Name -like '*flexnet*' -or $_.Name -like '*autodesk*'
                        } | ForEach-Object {
                            Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
                            Write-ActionLog "Removed licensing file: $($_.FullName)"
                        }
                    } else {
                        Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed licensing path: $path"
                    }
                }
            } catch {
                Write-ActionLog "Could not remove licensing path: $path - $($_.Exception.Message)"
            }
        }
        
        # Clean licensing registry entries
        Clear-LicensingRegistryEntries
        
        # Clean user-specific licensing data
        Clear-UserLicensingData
        
        # Reset licensing services
        Reset-LicensingServices
    }
}

<#
.SYNOPSIS
    Clears licensing-specific registry entries
.DESCRIPTION
    Removes FLEXnet, ADLM, and Autodesk licensing registry keys
#>
function Clear-LicensingRegistryEntries {
    Write-ActionLog "Cleaning licensing registry entries..."
    
    $licensingRegPaths = @(
        'HKLM:\SOFTWARE\FLEXlm License Manager',
        'HKLM:\SOFTWARE\Wow6432Node\FLEXlm License Manager',
        'HKCU:\SOFTWARE\FLEXlm License Manager',
        'HKLM:\SOFTWARE\Autodesk\ADLM',
        'HKLM:\SOFTWARE\Wow6432Node\Autodesk\ADLM',
        'HKCU:\SOFTWARE\Autodesk\ADLM',
        'HKLM:\SOFTWARE\Macrovision',
        'HKLM:\SOFTWARE\Wow6432Node\Macrovision',
        'HKCU:\SOFTWARE\Macrovision'
    )
    
    foreach ($regPath in $licensingRegPaths) {
        try {
            if (Test-Path $regPath) {
                Remove-Item $regPath -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed licensing registry path: $regPath"
            }
        } catch {
            Write-ActionLog "Could not remove licensing registry path: $regPath - $($_.Exception.Message)"
        }
    }
}

<#
.SYNOPSIS
    Clears user-specific licensing data
.DESCRIPTION
    Removes licensing data from all user profiles
#>
function Clear-UserLicensingData {
    Write-ActionLog "Cleaning user licensing data..."
    
    $profiles = Get-UserProfiles
    
    foreach ($userProfile in $profiles) {
        $profilePath = $userProfile.ProfileImagePath
        
        $userLicensingPaths = @(
            'AppData\Local\Autodesk\ADLM',
            'AppData\Roaming\Autodesk\ADLM',
            'AppData\Local\FLEXnet',
            'AppData\Roaming\FLEXnet'
        )
        
        foreach ($licPath in $userLicensingPaths) {
            $fullPath = Join-Path $profilePath $licPath
            if (Test-Path $fullPath) {
                try {
                    Remove-Item $fullPath -Recurse -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed user licensing data: $fullPath"
                } catch {
                    Write-ActionLog "Could not remove user licensing data: $fullPath"
                }
            }
        }
    }
}

<#
.SYNOPSIS
    Resets licensing services to ensure clean state
.DESCRIPTION
    Removes and recreates licensing services if needed
#>
function Reset-LicensingServices {
    Write-ActionLog "Resetting licensing services..."
    
    $licensingServices = @(
        'AdskLicensingService',
        'FNPLicensingService', 
        'GenuineService',
        'AdAppMgrSvc'
    )
    
    foreach ($serviceName in $licensingServices) {
        try {
            # Stop the service
            Stop-Service $serviceName -Force -ErrorAction SilentlyContinue
            
            # Delete the service
            $deleteResult = & sc.exe delete $serviceName 2>&1
            Write-ActionLog "Service deletion result for $serviceName`: $deleteResult"
            
        } catch {
            Write-ActionLog "Could not reset service: $serviceName - $($_.Exception.Message)"
        }
    }
    
    # Clear service registry remnants
    $serviceRegPaths = @(
        'HKLM:\SYSTEM\CurrentControlSet\Services\AdskLicensingService',
        'HKLM:\SYSTEM\CurrentControlSet\Services\FNPLicensingService',
        'HKLM:\SYSTEM\CurrentControlSet\Services\GenuineService',
        'HKLM:\SYSTEM\CurrentControlSet\Services\AdAppMgrSvc'
    )
    
    foreach ($regPath in $serviceRegPaths) {
        try {
            if (Test-Path $regPath) {
                Remove-Item $regPath -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed service registry: $regPath"
            }
        } catch {
            Write-ActionLog "Could not remove service registry: $regPath"
        }
    }
}

<#
.SYNOPSIS
    Clears Autodesk shared components that cause schema and startup errors
.DESCRIPTION
    Removes shared components, schemas, and libraries that can cause application startup issues.
    In reinstall mode, preserves critical components like AdskIdentityManager.
.PARAMETER PreserveComponents
    If true, preserves critical shared components for reinstall scenarios
#>
function Clear-AutodeskSharedComponents {
    param(
        [bool]$PreserveComponents = $false
    )
    
    if ($PreserveComponents) {
        Write-ActionLog "Cleaning Autodesk shared components (REINSTALL MODE - preserving critical components)..."
    } else {
        Write-ActionLog "Cleaning Autodesk shared components (FULL UNINSTALL MODE)..."
    }
    
    $config = Get-Config
    
    if ($PreserveComponents) {
        # Reinstall mode: Only clean safe paths and specific problematic folders
        Write-ActionLog "Preserving AdskIdentityManager and other critical licensing components..."
        
        # Clean only safe cache/temp/log paths
        $pathsToClean = $config.SafeToCleanPaths
        
        foreach ($path in $pathsToClean) {
            try {
                if ($path -match '\*') {
                    $items = Get-Item $path -ErrorAction SilentlyContinue
                    foreach ($item in $items) {
                        Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Cleaned safe shared component: $($item.FullName)"
                    }
                } else {
                    if (Test-Path $path) {
                        Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Cleaned safe shared component path: $path"
                    }
                }
            } catch {
                Write-ActionLog "Could not clean safe path: $path - $($_.Exception.Message)"
            }
        }
        
        # Clean only Revit schemas and materials (common problem areas)
        Clear-RevitSchemas
        Clear-SharedMaterialLibraries
        
    } else {
        # Full uninstall mode: Clean more aggressively but still preserve some system components
        $sharedPaths = $config.SharedComponentPaths
        
        foreach ($path in $sharedPaths) {
            try {
                if ($path -match '\*') {
                    $items = Get-Item $path -ErrorAction SilentlyContinue
                    foreach ($item in $items) {
                        Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed shared component: $($item.FullName)"
                    }
                } else {
                    if (Test-Path $path) {
                        Remove-Item $path -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed shared component path: $path"
                    }
                }
            } catch {
                Write-ActionLog "Could not remove shared component path: $path - $($_.Exception.Message)"
            }
        }
        
        # Clean all schema and material locations
        Clear-RevitSchemas
        Clear-SharedMaterialLibraries 
        Clear-SharedTemplateData
        
        # In full uninstall, also clean broader shared folders but preserve critical licensing
        $criticalComponents = $config.CriticalSharedComponents
        $broadPaths = @(
            'C:\Program Files\Common Files\Autodesk Shared',
            'C:\Program Files (x86)\Common Files\Autodesk Shared',
            'C:\ProgramData\Autodesk\Shared'
        )
        
        foreach ($broadPath in $broadPaths) {
            if (Test-Path $broadPath) {
                try {
                    # Get all subdirectories
                    $subDirs = Get-ChildItem $broadPath -Directory -ErrorAction SilentlyContinue
                    
                    foreach ($subDir in $subDirs) {
                        $isCritical = $false
                        
                        # Check if this is a critical component to preserve
                        foreach ($criticalPath in $criticalComponents) {
                            if ($subDir.FullName -like "*$($criticalPath.Split('\')[-1])*") {
                                $isCritical = $true
                                Write-ActionLog "PRESERVED critical component: $($subDir.FullName)"
                                break
                            }
                        }
                        
                        if (-not $isCritical) {
                            Remove-Item $subDir.FullName -Recurse -Force -ErrorAction SilentlyContinue
                            Write-ActionLog "Removed non-critical shared component: $($subDir.FullName)"
                        }
                    }
                } catch {
                    Write-ActionLog "Could not process broad shared path: $broadPath - $($_.Exception.Message)"
                }
            }
        }
    }
}

<#
.SYNOPSIS
    Clears Revit schema folders specifically
.DESCRIPTION
    Removes all Revit schema folders that can cause startup issues
#>
function Clear-RevitSchemas {
    Write-ActionLog "Cleaning Revit schema folders..."
    
    $schemaPaths = @(
        'C:\Program Files\Common Files\Autodesk Shared\Revit Schemas*',
        'C:\Program Files (x86)\Common Files\Autodesk Shared\Revit Schemas*',
        'C:\ProgramData\Autodesk\Revit\Schemas*',
        'C:\Users\*\AppData\Local\Autodesk\Revit\*\Schemas',
        'C:\Users\*\AppData\Roaming\Autodesk\Revit\*\Schemas'
    )
    
    foreach ($schemaPath in $schemaPaths) {
        try {
            $items = Get-Item $schemaPath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed schema folder: $($item.FullName)"
            }
        } catch {
            Write-ActionLog "Could not remove schema path: $schemaPath"
        }
    }
}

<#
.SYNOPSIS
    Clears shared material libraries
.DESCRIPTION
    Removes corrupted or incomplete material libraries
#>
function Clear-SharedMaterialLibraries {
    Write-ActionLog "Cleaning shared material libraries..."
    
    $materialPaths = @(
        'C:\Program Files\Common Files\Autodesk Shared\Materials*',
        'C:\Program Files (x86)\Common Files\Autodesk Shared\Materials*',
        'C:\ProgramData\Autodesk\Libraries*',
        'C:\Users\*\AppData\Local\Autodesk\*\Libraries',
        'C:\Users\*\AppData\Roaming\Autodesk\*\Libraries'
    )
    
    foreach ($materialPath in $materialPaths) {
        try {
            $items = Get-Item $materialPath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                # Only remove if it looks corrupted or incomplete
                if ($item.GetFiles().Count -eq 0 -or (Get-ChildItem $item.FullName -ErrorAction SilentlyContinue).Count -lt 5) {
                    Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed incomplete material library: $($item.FullName)"
                }
            }
        } catch {
            Write-ActionLog "Could not check material path: $materialPath"
        }
    }
}

<#
.SYNOPSIS
    Clears shared template and font data
.DESCRIPTION
    Removes template and font data that can cause startup issues
#>
function Clear-SharedTemplateData {
    Write-ActionLog "Cleaning shared template and font data..."
    
    $templatePaths = @(
        'C:\Program Files\Common Files\Autodesk Shared\Templates*',
        'C:\Program Files (x86)\Common Files\Autodesk Shared\Templates*',
        'C:\ProgramData\Autodesk\Templates*',
        'C:\Program Files\Common Files\Autodesk Shared\Fonts*',
        'C:\Program Files (x86)\Common Files\Autodesk Shared\Fonts*'
    )
    
    foreach ($templatePath in $templatePaths) {
        try {
            $items = Get-Item $templatePath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed template/font data: $($item.FullName)"
            }
        } catch {
            Write-ActionLog "Could not remove template path: $templatePath"
        }
    }
}

<#
.SYNOPSIS
    Clears Autodesk registry entries that can interfere with reinstallation
.DESCRIPTION
    Removes registry keys and values related to Autodesk products
#>
function Clear-AutodeskRegistryEntries {
    Write-ActionLog "Cleaning Autodesk registry entries..."
    
    $config = Get-Config
    $registryPaths = $config.RegistryCleanupPaths
    
    foreach ($regPath in $registryPaths) {
        try {
            if (Test-Path $regPath) {
                # For service entries, stop and remove the service first
                if ($regPath -match 'Services\\(.+)$') {
                    $serviceName = $matches[1]
                    try {
                        Stop-Service $serviceName -Force -ErrorAction SilentlyContinue
                        sc.exe delete $serviceName | Out-Null
                        Write-ActionLog "Removed service: $serviceName"
                    } catch {
                        Write-ActionLog "Could not remove service: $serviceName"
                    }
                }
                
                Remove-Item $regPath -Recurse -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Removed registry path: $regPath"
            }
        } catch {
            Write-ActionLog "Could not remove registry path: $regPath - $($_.Exception.Message)"
        }
    }
    
    # Clean SharedDLLs entries
    try {
        $sharedDllPath = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedDLLs'
        if (Test-Path $sharedDllPath) {
            $sharedDlls = Get-ItemProperty $sharedDllPath -ErrorAction SilentlyContinue
            if ($sharedDlls) {
                $sharedDlls.PSObject.Properties | Where-Object { $_.Name -like '*autodesk*' -or $_.Name -like '*adlm*' } | ForEach-Object {
                    Remove-ItemProperty -Path $sharedDllPath -Name $_.Name -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed SharedDLL entry: $($_.Name)"
                }
            }
        }
    } catch {
        Write-ActionLog "Could not clean SharedDLLs entries: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Clears Autodesk system files that can interfere with reinstallation
.DESCRIPTION
    Removes system-level Autodesk files and libraries
#>
function Clear-AutodeskSystemFiles {
    Write-ActionLog "Cleaning Autodesk system files..."
    
    $config = Get-Config
    $systemPaths = $config.SystemCleanupPaths
    
    foreach ($pathPattern in $systemPaths) {
        try {
            if ($pathPattern -match '\*') {
                # Handle wildcards
                $items = Get-Item $pathPattern -ErrorAction SilentlyContinue
                foreach ($item in $items) {
                    if ($item.Name -like '*autodesk*' -or $item.Name -like '*adlm*') {
                        Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed system file/folder: $($item.FullName)"
                    }
                }
            } else {
                if (Test-Path $pathPattern) {
                    Remove-Item $pathPattern -Recurse -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed system path: $pathPattern"
                }
            }
        } catch {
            Write-ActionLog "Could not remove system path: $pathPattern - $($_.Exception.Message)"
        }
    }
}

<#
.SYNOPSIS
    Clears Autodesk entries from Windows Installer cache
.DESCRIPTION
    Removes cached MSI files and installer database entries
#>
function Clear-AutodeskInstallerCache {
    Write-ActionLog "Cleaning Windows Installer cache..."
    
    try {
        # Clean MSI cache
        $msiCachePath = "$env:WINDIR\Installer"
        if (Test-Path $msiCachePath) {
            Get-ChildItem $msiCachePath -Filter "*.msi" | ForEach-Object {
                try {
                    $msiInfo = & msiexec /qn /l* "$env:TEMP\msi_check.log" /i $_.FullName REINSTALLMODE=vomus REINSTALL=ALL 2>$null
                    $logContent = Get-Content "$env:TEMP\msi_check.log" -ErrorAction SilentlyContinue
                    if ($logContent -join ' ' -match 'autodesk|adlm') {
                        Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed MSI cache file: $($_.Name)"
                    }
                    Remove-Item "$env:TEMP\msi_check.log" -ErrorAction SilentlyContinue
                } catch {
                    # Skip files we can't process
                }
            }
        }
    } catch {
        Write-ActionLog "Could not clean MSI cache: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Resets Windows Installer database to clear any corruption
.DESCRIPTION
    Restarts Windows Installer service and clears temporary files
#>
function Reset-WindowsInstallerDatabase {
    Write-ActionLog "Resetting Windows Installer database..."
    
    try {
        # Stop Windows Installer service
        Stop-Service "msiserver" -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
        
        # Clear Windows Installer temp files
        $tempPaths = @(
            "$env:TEMP\*.msi",
            "$env:TEMP\*.msp",
            "$env:TEMP\*.mst",
            "$env:WINDIR\Temp\*.msi",
            "$env:WINDIR\Temp\*.msp",
            "$env:WINDIR\Temp\*.mst"
        )
        
        foreach ($tempPath in $tempPaths) {
            Get-Item $tempPath -ErrorAction SilentlyContinue | Remove-Item -Force -ErrorAction SilentlyContinue
        }
        
        # Restart Windows Installer service
        Start-Service "msiserver" -ErrorAction SilentlyContinue
        Write-ActionLog "Windows Installer service reset completed"
        
    } catch {
        Write-ActionLog "Could not reset Windows Installer database: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Clears Autodesk-related files from Desktop
.DESCRIPTION
    Removes Autodesk shortcuts, installers, and related files from the Desktop
.PARAMETER ProfilePath
    The path to the user profile
#>
function Clear-DesktopAutodeskFiles {
    param([string]$ProfilePath)
    
    $desktopPath = Join-Path $ProfilePath "Desktop"
    if (Test-Path $desktopPath) {
        Write-ActionLog "Checking Desktop for Autodesk files: $desktopPath"
        
        # Autodesk-related file patterns to look for
        $autodeskPatterns = @(
            '*Autodesk*',
            '*Revit*',
            '*AutoCAD*',
            '*3ds Max*',
            '*Maya*',
            '*Inventor*',
            '*Navisworks*',
            '*Civil 3D*',
            '*Fusion*',
            '*Desktop Connector*'
        )
        
        foreach ($pattern in $autodeskPatterns) {
            $matchingFiles = Get-ChildItem $desktopPath -Name $pattern -ErrorAction SilentlyContinue
            foreach ($file in $matchingFiles) {
                $fullPath = Join-Path $desktopPath $file
                try {
                    if (Test-Path $fullPath) {
                        Remove-Item $fullPath -Recurse -Force -ErrorAction Stop
                        Write-ActionLog "Removed from Desktop: $fullPath"
                    }
                } catch {
                    Write-ActionLog "Could not remove from Desktop: $fullPath - $($_.Exception.Message)"
                }
            }
        }
    }
}

<#
.SYNOPSIS
    Runs system maintenance to resolve potential installation issues
.DESCRIPTION
    Executes system commands to repair registry and file system issues
#>
function Invoke-SystemMaintenance {
    Write-ActionLog "Running system maintenance to resolve installation issues..."
    
    try {
        # Run System File Checker to repair any corrupted system files
        Write-ActionLog "Running System File Checker..."
        $sfcResult = & sfc /scannow 2>&1
        Write-ActionLog "SFC completed: $($sfcResult -join ' ')"
        
        # Run DISM to repair Windows image
        Write-ActionLog "Running DISM health check..."
        $dismResult = & dism /online /cleanup-image /restorehealth 2>&1
        Write-ActionLog "DISM completed: $($dismResult -join ' ')"
        
        # Clear Windows Update cache that might interfere
        Write-ActionLog "Clearing Windows Update cache..."
        Stop-Service "wuauserv" -Force -ErrorAction SilentlyContinue
        Remove-Item "$env:WINDIR\SoftwareDistribution\Download\*" -Recurse -Force -ErrorAction SilentlyContinue
        Start-Service "wuauserv" -ErrorAction SilentlyContinue
        
        # Repair licensing components
        Repair-AutodeskLicensing
        
        # Repair shared components and schemas
        Repair-AutodeskSharedComponents
        
        # Fix Windows Installer issues to prevent error 1603
        Fix-WindowsInstallerIssues
        
        # Clear installation rollback files
        Clear-InstallationRollbackFiles
        
        # Fix registry permissions
        Fix-RegistryPermissions
        
        Write-ActionLog "System maintenance completed - ready for error-free installation"
        
    } catch {
        Write-ActionLog "System maintenance encountered issues: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Repairs Autodesk licensing components to prevent "License Manager not functioning" errors
.DESCRIPTION
    Attempts to repair or reinstall licensing components using Windows built-in tools
#>
function Repair-AutodeskLicensing {
    Write-ActionLog "Attempting to repair Autodesk licensing components..."
    
    try {
        # Re-register licensing DLLs that might be needed
        $licensingDlls = @(
            "$env:WINDIR\System32\msvcr*.dll",
            "$env:WINDIR\System32\msvcp*.dll",
            "$env:WINDIR\SysWOW64\msvcr*.dll",
            "$env:WINDIR\SysWOW64\msvcp*.dll"
        )
        
        foreach ($dllPattern in $licensingDlls) {
            Get-Item $dllPattern -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    & regsvr32 /s $_.FullName
                    Write-ActionLog "Re-registered DLL: $($_.Name)"
                } catch {
                    Write-ActionLog "Could not register DLL: $($_.Name)"
                }
            }
        }
        
        # Reset Windows licensing and activation services
        Write-ActionLog "Resetting Windows licensing services..."
        $windowsLicensingServices = @('sppsvc', 'wlidsvc', 'LicenseManager')
        foreach ($service in $windowsLicensingServices) {
            try {
                Restart-Service $service -Force -ErrorAction SilentlyContinue
                Write-ActionLog "Restarted service: $service"
            } catch {
                Write-ActionLog "Could not restart service: $service"
            }
        }
        
        # Clear licensing cache directories
        Write-ActionLog "Clearing licensing cache..."
        $cachePaths = @(
            "$env:ALLUSERSPROFILE\Autodesk\ADLM\*",
            "$env:LOCALAPPDATA\Autodesk\ADLM\*",
            "$env:TEMP\*adlm*",
            "$env:TEMP\*flexnet*"
        )
        
        foreach ($cachePath in $cachePaths) {
            Get-Item $cachePath -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        }
        
        Write-ActionLog "Licensing repair completed"
        
    } catch {
        Write-ActionLog "Licensing repair encountered issues: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Repairs Autodesk shared components to prevent schema and startup errors
.DESCRIPTION
    Creates basic folder structure and attempts to repair shared components
#>
function Repair-AutodeskSharedComponents {
    Write-ActionLog "Attempting to repair Autodesk shared components..."
    
    try {
        # Create basic shared component folder structure
        $sharedBasePaths = @(
            'C:\Program Files\Common Files\Autodesk Shared',
            'C:\Program Files (x86)\Common Files\Autodesk Shared',
            'C:\ProgramData\Autodesk\Shared'
        )
        
        foreach ($basePath in $sharedBasePaths) {
            try {
                if (-not (Test-Path $basePath)) {
                    New-Item -ItemType Directory -Path $basePath -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Created shared folder: $basePath"
                }
            } catch {
                Write-ActionLog "Could not create shared folder: $basePath"
            }
        }
        
        # Register common shared DLLs
        $sharedDlls = @(
            'C:\Program Files\Common Files\Autodesk Shared\*.dll',
            'C:\Program Files (x86)\Common Files\Autodesk Shared\*.dll'
        )
        
        foreach ($dllPattern in $sharedDlls) {
            Get-Item $dllPattern -ErrorAction SilentlyContinue | ForEach-Object {
                try {
                    & regsvr32 /s $_.FullName
                    Write-ActionLog "Registered shared DLL: $($_.Name)"
                } catch {
                    Write-ActionLog "Could not register shared DLL: $($_.Name)"
                }
            }
        }
        
        # Reset Windows Component Store for Autodesk components
        Write-ActionLog "Resetting Windows Component Store..."
        try {
            & dism /online /cleanup-image /startcomponentcleanup /resetbase 2>&1 | Out-Null
            Write-ActionLog "Component store cleanup completed"
        } catch {
            Write-ActionLog "Component store cleanup failed"
        }
        
        Write-ActionLog "Shared components repair completed"
        
    } catch {
        Write-ActionLog "Shared components repair encountered issues: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Tests if a system reboot is pending
.DESCRIPTION
    Checks various registry locations and system states to determine if a reboot is required
.OUTPUTS
    Boolean indicating if a reboot is pending
#>
function Test-PendingReboot {
    Write-ActionLog "Checking for pending system reboot..."
    
    $pendingReboot = $false
    $reasons = @()
    
    try {
        # Check Windows Update
        if (Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" -ErrorAction SilentlyContinue) {
            $pendingReboot = $true
            $reasons += "Windows Update requires reboot"
        }
        
        # Check Component Based Servicing
        if (Get-Item "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending" -ErrorAction SilentlyContinue) {
            $pendingReboot = $true
            $reasons += "Component Based Servicing requires reboot"
        }
        
        # Check PendingFileRenameOperations
        $pendingFileRename = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "PendingFileRenameOperations" -ErrorAction SilentlyContinue
        if ($pendingFileRename) {
            $pendingReboot = $true
            $reasons += "Pending file rename operations require reboot"
        }
        
        # Check if Computer Name is changing
        $computerName = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName" -ErrorAction SilentlyContinue
        $pendingComputerName = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName" -ErrorAction SilentlyContinue
        if ($computerName -and $pendingComputerName -and $computerName.ComputerName -ne $pendingComputerName.ComputerName) {
            $pendingReboot = $true
            $reasons += "Computer name change requires reboot"
        }
        
        # Check Configuration Manager Client SDK
        if (Get-Service -Name CcmExec -ErrorAction SilentlyContinue) {
            try {
                $sccmClient = New-Object -ComObject Microsoft.SMS.TSEnvironment -ErrorAction SilentlyContinue
                if ($sccmClient -and $sccmClient.Value("_SMSTSInWinPE") -ne "false") {
                    $pendingReboot = $true
                    $reasons += "SCCM requires reboot"
                }
            } catch {
                # SCCM check failed, continue
            }
        }
        
        if ($pendingReboot) {
            Write-ActionLog "PENDING REBOOT DETECTED! Reasons: $($reasons -join '; ')"
            Write-ActionLog "IMPORTANT: Please reboot the system before running the uninstaller to ensure clean removal."
            Write-ActionLog "Continuing with uninstall, but some operations may fail or be incomplete."
        } else {
            Write-ActionLog "No pending reboot detected - system is ready for uninstall"
        }
        
        return $pendingReboot
        
    } catch {
        Write-ActionLog "Error checking for pending reboot: $($_.Exception.Message)"
        return $false
    }
}

<#
.SYNOPSIS
    Tests if uninstall was successful by checking for remaining products
.DESCRIPTION
    Verifies that products have been properly removed from the system registry
.OUTPUTS
    Boolean indicating if uninstall verification passed
#>
function Test-UninstallSuccess {
    Write-ActionLog "Verifying uninstall success..."
    
    try {
        $remainingProducts = Find-AutodeskProducts
        
        if ($remainingProducts.Count -eq 0) {
            Write-ActionLog "SUCCESS: No Autodesk products found in registry - uninstall appears complete"
            return $true
        } else {
            Write-ActionLog "WARNING: $($remainingProducts.Count) products still found in registry after uninstall:"
            foreach ($product in $remainingProducts) {
                Write-ActionLog "  - $($product.DisplayName) (Version: $($product.DisplayVersion))"
            }
            
            # Check if these are just leftover registry entries without actual files
            $productsWithFiles = 0
            foreach ($product in $remainingProducts) {
                if ($product.InstallLocation -and (Test-Path $product.InstallLocation)) {
                    $productsWithFiles++
                    Write-ActionLog "    Files still exist at: $($product.InstallLocation)"
                }
            }
            
            if ($productsWithFiles -eq 0) {
                Write-ActionLog "PARTIAL SUCCESS: Registry entries remain but no program files found"
                return $true
            } else {
                Write-ActionLog "PARTIAL FAILURE: $productsWithFiles products still have files on disk"
                return $false
            }
        }
        
    } catch {
        Write-ActionLog "Error verifying uninstall success: $($_.Exception.Message)"
        return $false
    }
}

<#
.SYNOPSIS
    Performs final cleanup verification and system maintenance
.DESCRIPTION
    Kills any remaining processes, clears temp files, and reports final system state
#>
function Invoke-FinalCleanupVerification {
    Write-ActionLog "Performing final cleanup verification..."
    
    try {
        # Kill any lingering Autodesk processes
        Write-ActionLog "Checking for lingering Autodesk processes..."
        $config = Get-Config
        $processes = $config.AutodeskProcesses
        
        $killedProcesses = 0
        foreach ($processName in $processes) {
            $runningProcesses = Get-Process -Name $processName -ErrorAction SilentlyContinue
            foreach ($process in $runningProcesses) {
                try {
                    $process.Kill()
                    $killedProcesses++
                    Write-ActionLog "Killed lingering process: $processName (PID: $($process.Id))"
                } catch {
                    Write-ActionLog "Could not kill process: $processName (PID: $($process.Id))"
                }
            }
        }
        
        if ($killedProcesses -eq 0) {
            Write-ActionLog "No lingering Autodesk processes found"
        }
        
        # Check and stop any remaining Autodesk services
        Write-ActionLog "Checking for lingering Autodesk services..."
        $services = $config.AutodeskServices
        $stoppedServices = 0
        
        foreach ($serviceName in $services) {
            $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
            if ($service -and $service.Status -eq 'Running') {
                try {
                    Stop-Service $serviceName -Force -ErrorAction Stop
                    Set-Service $serviceName -StartupType Disabled -ErrorAction SilentlyContinue
                    $stoppedServices++
                    Write-ActionLog "Stopped lingering service: $serviceName"
                } catch {
                    Write-ActionLog "Could not stop service: $serviceName"
                }
            }
        }
        
        if ($stoppedServices -eq 0) {
            Write-ActionLog "No lingering Autodesk services found"
        }
        
        # Clear temporary files
        Write-ActionLog "Clearing temporary files..."
        $tempPaths = @(
            "$env:TEMP\*autodesk*",
            "$env:TEMP\*adlm*",
            "$env:TEMP\*revit*",
            "$env:TEMP\*autocad*",
            "$env:WINDIR\Temp\*autodesk*",
            "$env:WINDIR\Temp\*adlm*"
        )
        
        $clearedFiles = 0
        foreach ($tempPath in $tempPaths) {
            $items = Get-Item $tempPath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                try {
                    Remove-Item $item -Recurse -Force -ErrorAction Stop
                    $clearedFiles++
                    Write-ActionLog "Cleared temp item: $($item.Name)"
                } catch {
                    Write-ActionLog "Could not clear temp item: $($item.Name)"
                }
            }
        }
        
        if ($clearedFiles -eq 0) {
            Write-ActionLog "No temporary Autodesk files found to clear"
        }
        
        # Report disk space freed (basic check)
        Write-ActionLog "Checking disk space..."
        try {
            $disk = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction SilentlyContinue
            if ($disk) {
                $freeSpaceGB = [math]::Round($disk.FreeSpace / 1GB, 2)
                $totalSpaceGB = [math]::Round($disk.Size / 1GB, 2)
                $usedSpaceGB = $totalSpaceGB - $freeSpaceGB
                $freePercentage = [math]::Round(($freeSpaceGB / $totalSpaceGB) * 100, 1)
                
                Write-ActionLog "Disk Space Status:"
                Write-ActionLog "  Total: $totalSpaceGB GB"
                Write-ActionLog "  Used: $usedSpaceGB GB"
                Write-ActionLog "  Free: $freeSpaceGB GB ($freePercentage%)"
            }
        } catch {
            Write-ActionLog "Could not retrieve disk space information"
        }
        
        # Final system state summary
        Write-ActionLog "=== FINAL CLEANUP VERIFICATION COMPLETE ==="
        Write-ActionLog "Processes killed: $killedProcesses"
        Write-ActionLog "Services stopped: $stoppedServices"  
        Write-ActionLog "Temp files cleared: $clearedFiles"
        
        return $true
        
    } catch {
        Write-ActionLog "Error during final cleanup verification: $($_.Exception.Message)"
        return $false
    }
}

<#
.SYNOPSIS
    Fixes Windows Installer issues that cause error 1603
.DESCRIPTION
    Addresses common Windows Installer problems that prevent successful Autodesk installation
#>
function Fix-WindowsInstallerIssues {
    Write-ActionLog "Fixing Windows Installer issues to prevent error 1603..."
    
    try {
        # Stop Windows Installer service
        Write-ActionLog "Stopping Windows Installer service..."
        Stop-Service -Name "msiserver" -Force -ErrorAction SilentlyContinue
        
        # Clear Windows Installer cache corruption
        Write-ActionLog "Clearing Windows Installer cache..."
        $msiCachePaths = @(
            "$env:WINDIR\Installer\*autodesk*",
            "$env:WINDIR\Installer\*adlm*",
            "$env:WINDIR\Installer\*revit*",
            "$env:WINDIR\Installer\*autocad*"
        )
        
        foreach ($cachePath in $msiCachePaths) {
            $items = Get-Item $cachePath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                try {
                    Remove-Item $item.FullName -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed MSI cache: $($item.Name)"
                } catch {
                    Write-ActionLog "Could not remove MSI cache: $($item.Name)"
                }
            }
        }
        
        # Fix Windows Installer registry corruption
        Write-ActionLog "Fixing Windows Installer registry..."
        $installerRegPaths = @(
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products',
            'HKLM:\SOFTWARE\Classes\Installer\Features',
            'HKLM:\SOFTWARE\Classes\Installer\Products'
        )
        
        foreach ($regPath in $installerRegPaths) {
            try {
                if (Test-Path $regPath) {
                    $keys = Get-ChildItem $regPath -ErrorAction SilentlyContinue
                    foreach ($key in $keys) {
                        $keyProps = Get-ItemProperty $key.PSPath -ErrorAction SilentlyContinue
                        if ($keyProps) {
                            $isAutodesk = $false
                            
                            # Check if this is an Autodesk product
                            foreach ($prop in $keyProps.PSObject.Properties) {
                                if ($prop.Value -and $prop.Value.ToString() -match "autodesk|adlm|revit|autocad|3ds|maya|inventor") {
                                    $isAutodesk = $true
                                    break
                                }
                            }
                            
                            if ($isAutodesk) {
                                Remove-Item $key.PSPath -Recurse -Force -ErrorAction SilentlyContinue
                                Write-ActionLog "Removed corrupted installer entry: $($key.Name)"
                            }
                        }
                    }
                }
            } catch {
                Write-ActionLog "Could not clean installer registry: $regPath - $($_.Exception.Message)"
            }
        }
        
        # Clear temp installation files
        Write-ActionLog "Clearing temporary installation files..."
        $tempPaths = @(
            "$env:TEMP\*autodesk*",
            "$env:TEMP\*adlm*",
            "$env:TEMP\MSI*.tmp",
            "$env:WINDIR\Temp\*autodesk*",
            "$env:WINDIR\Temp\*adlm*",
            "$env:ALLUSERSPROFILE\Package Cache\*autodesk*",
            "$env:ALLUSERSPROFILE\Package Cache\*adlm*"
        )
        
        foreach ($tempPath in $tempPaths) {
            $items = Get-Item $tempPath -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                try {
                    Remove-Item $item.FullName -Recurse -Force -ErrorAction SilentlyContinue
                    Write-ActionLog "Removed temp file: $($item.Name)"
                } catch {
                    Write-ActionLog "Could not remove temp file: $($item.Name)"
                }
            }
        }
        
        # Restart Windows Installer service
        Write-ActionLog "Restarting Windows Installer service..."
        Start-Service -Name "msiserver" -ErrorAction SilentlyContinue
        
        # Wait for service to be ready
        Start-Sleep -Seconds 3
        
        Write-ActionLog "Windows Installer issues fixed"
        
    } catch {
        Write-ActionLog "Error fixing Windows Installer issues: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Clears installation rollback files that can cause error 1603
.DESCRIPTION
    Removes rollback and backup files that can interfere with new installations
#>
function Clear-InstallationRollbackFiles {
    Write-ActionLog "Clearing installation rollback files..."
    
    try {
        # Clear rollback files from Config.Msi folder
        $configMsiPath = "$env:WINDIR\Config.Msi"
        if (Test-Path $configMsiPath) {
            $rollbackFiles = Get-ChildItem $configMsiPath -Filter "*.rbf" -ErrorAction SilentlyContinue
            foreach ($file in $rollbackFiles) {
                try {
                    # Check if rollback file is related to Autodesk
                    $fileInfo = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                    if ($fileInfo -and $fileInfo -match "autodesk|adlm") {
                        Remove-Item $file.FullName -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed rollback file: $($file.Name)"
                    }
                } catch {
                    # If we can't read the file, remove it anyway if it's old
                    if ($file.LastWriteTime -lt (Get-Date).AddDays(-7)) {
                        Remove-Item $file.FullName -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed old rollback file: $($file.Name)"
                    }
                }
            }
        }
        
        # Clear Windows Installer patch files
        $patchPaths = @(
            "$env:WINDIR\Installer\*.msp",
            "$env:WINDIR\Installer\*.msi"
        )
        
        foreach ($patchPath in $patchPaths) {
            $patches = Get-Item $patchPath -ErrorAction SilentlyContinue
            foreach ($patch in $patches) {
                try {
                    # Use Windows Installer API to check if patch is related to Autodesk
                    $installer = New-Object -ComObject WindowsInstaller.Installer
                    $database = $installer.OpenDatabase($patch.FullName, 0)
                    $view = $database.OpenView("SELECT Value FROM Property WHERE Property='Manufacturer'")
                    $view.Execute()
                    $record = $view.Fetch()
                    if ($record -and $record.StringData(1) -match "Autodesk") {
                        Remove-Item $patch.FullName -Force -ErrorAction SilentlyContinue
                        Write-ActionLog "Removed Autodesk patch file: $($patch.Name)"
                    }
                    $database.Close()
                } catch {
                    # If we can't read the patch file, skip it
                    Write-ActionLog "Could not process patch file: $($patch.Name)"
                }
            }
        }
        
        Write-ActionLog "Installation rollback files cleared"
        
    } catch {
        Write-ActionLog "Error clearing rollback files: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Fixes registry permissions that can cause error 1603
.DESCRIPTION
    Ensures proper registry permissions for installation
#>
function Fix-RegistryPermissions {
    Write-ActionLog "Fixing registry permissions for installation..."
    
    try {
        # Fix permissions on installer registry keys
        $regPaths = @(
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer',
            'HKLM:\SOFTWARE\Classes\Installer',
            'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall'
        )
        
        foreach ($regPath in $regPaths) {
            if (Test-Path $regPath) {
                try {
                    # Grant full control to Administrators and System
                    $acl = Get-Acl $regPath
                    $accessRule = New-Object System.Security.AccessControl.RegistryAccessRule("Administrators", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
                    $acl.SetAccessRule($accessRule)
                    $accessRule = New-Object System.Security.AccessControl.RegistryAccessRule("SYSTEM", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
                    $acl.SetAccessRule($accessRule)
                    Set-Acl -Path $regPath -AclObject $acl
                    Write-ActionLog "Fixed permissions on: $regPath"
                } catch {
                    Write-ActionLog "Could not fix permissions on: $regPath"
                }
            }
        }
        
        Write-ActionLog "Registry permissions fixed"
        
    } catch {
        Write-ActionLog "Error fixing registry permissions: $($_.Exception.Message)"
    }
}

<#
.SYNOPSIS
    Performs comprehensive error 1603 prevention checks
.DESCRIPTION
    Runs all checks and fixes specifically designed to prevent MSI error 1603 during reinstallation
.OUTPUTS
    Boolean indicating if system is ready for installation
#>
function Test-InstallationReadiness {
    Write-ActionLog "Performing comprehensive installation readiness check..."
    
    $issues = @()
    $readinessScore = 0
    $maxScore = 8
    
    try {
        # Check 1: Pending reboot
        Write-ActionLog "Checking for pending reboot..."
        $pendingReboot = Test-PendingReboot
        if (-not $pendingReboot) {
            $readinessScore++
            Write-ActionLog "✓ No pending reboot detected"
        } else {
            $issues += "System has pending reboot"
            Write-ActionLog "✗ Pending reboot detected"
        }
        
        # Check 2: Windows Installer service
        Write-ActionLog "Checking Windows Installer service..."
        $msiService = Get-Service -Name "msiserver" -ErrorAction SilentlyContinue
        if ($msiService -and ($msiService.Status -eq 'Running' -or $msiService.Status -eq 'Stopped')) {
            $readinessScore++
            Write-ActionLog "✓ Windows Installer service is healthy"
        } else {
            $issues += "Windows Installer service issues"
            Write-ActionLog "✗ Windows Installer service problems detected"
        }
        
        # Check 3: No running MSI processes
        Write-ActionLog "Checking for running MSI processes..."
        $msiProcesses = Get-Process -Name "msiexec" -ErrorAction SilentlyContinue
        if (-not $msiProcesses) {
            $readinessScore++
            Write-ActionLog "✓ No MSI processes running"
        } else {
            $issues += "MSI installer processes still running"
            Write-ActionLog "✗ Found MSI processes running"
        }
        
        # Check 4: Temp space availability
        Write-ActionLog "Checking temporary space..."
        $tempDrive = Get-WmiObject -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction SilentlyContinue
        if ($tempDrive -and ($tempDrive.FreeSpace / 1GB) -gt 5) {
            $readinessScore++
            Write-ActionLog "✓ Sufficient temporary space available"
        } else {
            $issues += "Insufficient temporary disk space"
            Write-ActionLog "✗ Low temporary disk space detected"
        }
        
        # Check 5: User account permissions
        Write-ActionLog "Checking user permissions..."
        $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
        $principal = New-Object Security.Principal.WindowsPrincipal $currentUser
        if ($principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
            $readinessScore++
            Write-ActionLog "✓ Running with administrator privileges"
        } else {
            $issues += "Insufficient user privileges"
            Write-ActionLog "✗ Not running as administrator"
        }
        
        # Check 6: No conflicting Autodesk processes
        Write-ActionLog "Checking for conflicting processes..."
        $config = Get-Config
        $autodeskProcesses = @()
        foreach ($processName in $config.AutodeskProcesses) {
            $processes = Get-Process -Name $processName -ErrorAction SilentlyContinue
            $autodeskProcesses += $processes
        }
        if ($autodeskProcesses.Count -eq 0) {
            $readinessScore++
            Write-ActionLog "✓ No conflicting Autodesk processes running"
        } else {
            $issues += "Conflicting Autodesk processes still running"
            Write-ActionLog "✗ Found Autodesk processes still running"
        }
        
        # Check 7: No corrupted installer cache
        Write-ActionLog "Checking installer cache..."
        $installerCache = "$env:WINDIR\Installer"
        if (Test-Path $installerCache) {
            $orphanedFiles = Get-ChildItem $installerCache -Filter "*autodesk*" -ErrorAction SilentlyContinue
            if ($orphanedFiles.Count -eq 0) {
                $readinessScore++
                Write-ActionLog "✓ No corrupted Autodesk installer cache"
            } else {
                $issues += "Corrupted installer cache files found"
                Write-ActionLog "✗ Found orphaned Autodesk cache files"
            }
        } else {
            $readinessScore++
            Write-ActionLog "✓ No installer cache issues"
        }
        
        # Check 8: Windows Update status
        Write-ActionLog "Checking Windows Update status..."
        $wuService = Get-Service -Name "wuauserv" -ErrorAction SilentlyContinue
        if ($wuService -and $wuService.Status -eq 'Running') {
            $readinessScore++
            Write-ActionLog "✓ Windows Update service is healthy"
        } else {
            $issues += "Windows Update service issues"
            Write-ActionLog "✗ Windows Update service problems"
        }
        
        # Calculate final readiness
        $readinessPercentage = [math]::Round(($readinessScore / $maxScore) * 100, 1)
        
        Write-ActionLog "=== INSTALLATION READINESS REPORT ==="
        Write-ActionLog "Score: $readinessScore/$maxScore ($readinessPercentage)"
        
        if ($issues.Count -eq 0) {
            Write-ActionLog "SYSTEM READY FOR INSTALLATION"
            Write-ActionLog "No issues detected - installation should succeed"
            return $true
        } else {
            Write-ActionLog "ISSUES DETECTED:"
            foreach ($issue in $issues) {
                Write-ActionLog "  • $issue"
            }
            
            if ($readinessPercentage -ge 75) {
                Write-ActionLog "SYSTEM MOSTLY READY - Installation may succeed but monitor for issues"
                return $true
            } else {
                Write-ActionLog "SYSTEM NOT READY - Address issues before installation"
                return $false
            }
        }
        
    } catch {
        Write-ActionLog "Error during installation readiness check: $($_.Exception.Message)"
        return $false
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Stop-AutodeskServices',
    'Uninstall-Product',
    'Backup-AddIns',
    'Clear-ProductData',
    'Clear-AutodeskSystemRemnants',
    'Clear-AutodeskLicensingComponents',
    'Clear-AutodeskSharedComponents',
    'Invoke-SystemMaintenance',
    'Repair-AutodeskLicensing',
    'Repair-AutodeskSharedComponents',
    'Test-PendingReboot',
    'Test-UninstallSuccess',
    'Invoke-FinalCleanupVerification',
    'Fix-WindowsInstallerIssues',
    'Clear-InstallationRollbackFiles',
    'Fix-RegistryPermissions',
    'Test-InstallationReadiness'
)
